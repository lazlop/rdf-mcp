query_id,question_number,question,model,failure_category,failure_evidence,secondary_category
MORTAR_001,,What are the brick points in this graph?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked ""What are the brick points in this graph?"" expecting a list of point entities and their Brick class types. The ground-truth query returns ?point and its point type via rdf:type/subClassOf*. The generated query instead retrieves an optional rdfs:label and does not return the point type, indicating a misinterpretation of the request (label vs. type).",
MORTAR_001,,Can you find nodes that has information about an external reference?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for nodes that have information about an external reference, and the model generated a query using the (potentially non‑existent) predicate `brref:hasExternalReference`. However, the ground‑truth query expected by the evaluation retrieves Brick points (`?point rdf:type/rdfs:subClassOf* brick:Point`). The generated query focuses on an entirely different concept (external references) rather than selecting Brick points, indicating the model misinterpreted the intended task.",
MORTAR_001,,What points does this graph have?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the non‑existent predicate `brick:hasTag` and the tag class `bricktag:Point` (e.g., `?point brick:hasTag bricktag:Point .`). The Brick ontology does not define a `hasTag` property nor a `bricktag:Point` class; the correct approach is to retrieve instances whose rdf:type is a subclass of `brick:Point` as shown in the ground‑truth query (`?point rdf:type/rdfs:subClassOf* brick:Point`). This mismatch indicates the model fabricated vocabulary terms.",
MORTAR_001,,What data sources I have in my system?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked ""What data sources I have in my system?"" which, according to the ground‑truth, should be answered by listing all Brick points and their types (SELECT ?point ?point_type ...). Instead, the model generated a query that looks for external references and timeseries IDs (SELECT DISTINCT ?ts WHERE { ?entity <https://brickschema.org/schema/Brick/ref#hasExternalReference> ?ref . ?ref <https://brickschema.org/schema/Brick/ref#hasTimeseriesId> ?ts . }). This query addresses a different concept (external references) and therefore does not satisfy the user's intent.",
MORTAR_001,,Which entities that are instances of Point (including its subclasses) have which types?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for ""entities that are instances of Point (including its subclasses) have which types"". The ground‑truth query uses a property path `rdf:type/rdfs:subClassOf* brick:Point` to first identify any entity whose type (direct or indirect) falls under Brick:Point, then separately retrieves the entity's concrete type (`?point_type`). The generated query instead binds the entity's direct type first (`?entity rdf:type ?type`) and then filters that type with `?type rdfs:subClassOf* brick:Point`. This formulation can miss entities whose type is an indirect subclass of a subclass of Point, and it does not follow the intended two‑step logic of the question, showing a misunderstanding of the user's intent.",
MORTAR_001,,What point entities exist and what types are they assigned?,lbl/cborg-coder,Misunderstanding User Intent,"User query: ""What point entities exist and what types are they assigned?"" expects each point and its directly assigned Brick class (including indirect subclassing via rdf:type/rdfs:subClassOf*). Ground‑truth query uses a property path `rdf:type/rdfs:subClassOf* brick:Point` to first ensure the entity is a point, then selects the explicit type with `?point rdf:type ?point_type`. Generated query instead selects any `?type` that is a subclass of `brick:Point` and binds it to `?point rdf:type ?type`. This returns the superclass hierarchy rather than the actual type assigned to the point, showing the model misinterpreted the precise intent of returning the point's assigned type.",
MORTAR_001,,List all measurement points along with their categories.,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for all measurement points and their categories. The generated query forces each point to have a direct rdf:type triple `?point a brick:Point` and then filters subclasses, which excludes points that are instances of subclasses of Point. The correct pattern in the ground truth uses `rdf:type/rdfs:subClassOf* brick:Point` to capture both direct and indirect typing. This mismatch shows the model misinterpreted how to retrieve all points as intended.",
MORTAR_001,,What data points are defined in the building model and how are they classified?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for the data points defined in the building model and how they are classified. The ground‑truth query returns each point instance and its specific Brick subclass (SELECT ?point ?point_type ...). The generated query instead aggregates counts per point class (SELECT ?pointClass (COUNT(?point) AS ?count) ...) and does not provide the list of points or their classifications, showing the model misinterpreted the intent.",
MORTAR_001,,Which data points does the system include and how are they grouped?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for the data points included and how they are grouped. The ground‑truth query returns each point and its type (SELECT ?point ?point_type …). The generated query aggregates by point class and returns a count (SELECT ?pointClass (COUNT(?point) AS ?count) … GROUP BY ?pointClass), indicating the model interpreted the request as a summary rather than listing individual points, which misinterprets the user's intent.",
MORTAR_002,,Find all equipment and its points that are Zone Air Temperature Setpoints,lbl/cborg-coder,Topological Mismatch,"The generated query asserts `?setpoint a brick:Zone_Air_Temperature_Setpoint` which only matches individuals that are directly typed as that class. The ground‑truth query uses `?sp rdf:type/rdfs:subClassOf* brick:Zone_Air_Temperature_Setpoint` to traverse the subclass hierarchy, ensuring that any point that is a subclass of the setpoint class is included. By omitting the subclass traversal the model assumes a direct relationship that may not exist in the graph, leading to incomplete results.",
MORTAR_002,,What equipment has setpoints for zone air temperature and what are they?,lbl/cborg-coder,Topological Mismatch,"The generated query assumes that every setpoint is directly linked to equipment via `brick:hasPoint` (`?equipment brick:hasPoint ?setpoint`). The ground‑truth query accounts for both directions (`brick:hasPoint` and `brick:isPointOf`) and also traverses the subclass hierarchy (`rdf:type/rdfs:subClassOf* brick:Zone_Air_Temperature_Setpoint`). By omitting these alternatives, the generated query may miss setpoints that are connected via `brick:isPointOf` or that are instances of subclasses of `brick:Zone_Air_Temperature_Setpoint`, indicating a mismatch between the actual graph topology and the assumed one.",
MORTAR_002,,What are the Zone Air Temperature Setpoints and the equipment they belong to?,lbl/cborg-coder,Topological Mismatch,"The generated query only uses the direct triple `?equipment brick:hasPoint ?setpoint` to relate equipment to the setpoint. In many Brick graphs the relationship can also be expressed via the inverse property `brick:isPointOf` (or other indirect paths). By assuming a direct hasPoint edge, the query may miss equipment that are linked via the inverse relation, a classic topological mismatch.",
MORTAR_002,,Which equipment regulates the air temperature in rooms,lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct link between a temperature setpoint point and a room ( ?sp brick:isPointOf ?room . ?room a brick:Room ) and then connects that point to any brick:Equipment. The ground‑truth query instead looks for points that are subclasses of brick:Zone_Air_Temperature_Setpoint and then finds the equipment that has those points, reflecting the typical indirect topology (Room → VAV/AHU → Equipment). By forcing a direct Room‑Point relationship the model misrepresents the graph structure.",
MORTAR_002,,"For each point that is a zone air temperature setpoint, which equipment has that point?",lbl/cborg-coder,Topological Mismatch,"The generated query asserts `?setpoint a brick:Zone_Air_Temperature_Setpoint` assuming a direct rdf:type relationship, while the ground‑truth query uses `?sp rdf:type/rdfs:subClassOf* brick:Zone_Air_Temperature_Setpoint` to capture points that are subclasses of the setpoint class. This reflects a mismatch in the graph topology – the model ignored the need to traverse subclass relationships.",
MORTAR_002,,"Which devices include points that set the air temperature in a zone, and what are those points?",lbl/cborg-coder,Misunderstanding User Intent,"The ground‑truth query simply finds Equipment that has a point of type brick:Zone_Air_Temperature_Setpoint. The generated query adds many unnecessary constraints: it restricts devices to brick:HVAC_Equipment, uses the generic class brick:Temperature_Setpoint, attempts to locate a zone via ?point brick:hasLocation ?zone, and even filters on the point label containing the word ""air"". These additions indicate the model mis‑interpreted the user's request and introduced extra logic that was not asked for.",Topological Mismatch
MORTAR_002,,Which HVAC components provide setpoints for regulating zone air temperature and what are those setpoints called?,lbl/cborg-coder,Misunderstanding User Intent,"The generated query adds a filter '?component a brick:VAV' which restricts results to VAVs only, even though the user asked for all HVAC components that provide zone air temperature setpoints. The ground‑truth query does not impose any equipment type restriction and uses a subclass traversal to capture any setpoint class. This demonstrates the model misinterpreting the question by assuming the relevant components are VAVs.",
MORTAR_002,,What are the target temperatures for each zone and which devices supply these targets?,lbl/cborg-coder,Topological Mismatch,The generated query assumes a direct relationship `?zone brick:hasPoint ?tempSetpoint` (zone → temperature setpoint) and then finds a device `?device brick:hasPoint ?tempSetpoint`. The ground‑truth query does not involve zones at all; it selects setpoints that are subclasses of `brick:Zone_Air_Temperature_Setpoint` and then finds equipment that `brick:hasPoint` those setpoints. This mismatch between the assumed graph topology (Zone → Setpoint) and the actual topology (Equipment → Setpoint) indicates a topological mismatch.,
MORTAR_002,,Which equipment controls the temperature settings for building zones?,lbl/cborg-coder,Topological Mismatch,"The generated query adds an OPTIONAL block that assumes each temperature setpoint is directly linked to a zone via `brick:isPointOf ?zone` and that the zone is of type `brick:HVAC_Zone`. The ground‑truth query does not require any zone relationship at all; it only traverses the subclass hierarchy of `brick:Zone_Air_Temperature_Setpoint` and links equipment via `brick:hasPoint`. By imposing an extra topological constraint (equipment → setpoint → zone of a specific class) the query fails to match the actual graph structure, resulting in zero results.",
MORTAR_003,,Find all equipment and its points that are Supply Air Temperature Sensors,lbl/cborg-coder,Topological Mismatch,"The generated query uses a direct type assertion `?sensor a brick:Supply_Air_Temperature_Sensor` and expects a direct `brick:hasPoint` relationship, whereas the ground‑truth query employs `rdf:type/rdfs:subClassOf* brick:Supply_Air_Temperature_Sensor` to capture sensors that are instances of subclasses of the target class. This reflects an incorrect assumption of a direct relationship and ignores the subclass hierarchy, a classic topological mismatch.",
MORTAR_003,,What equipment has sensors for Supply air temperature and what are they?,lbl/cborg-coder,Misunderstanding User Intent,"The generated query adds extra constraints and optional pattern that are not required by the question or the ground‑truth query, e.g., it binds ?equip a ?equipClass and filters with FILTER(CONTAINS(STR(?equipClass), ""brick"")) and retrieves optional rdfs:label values. The user only asked for equipment that has supply‑air‑temperature sensors and the sensors themselves; the extra class filter and label look‑ups indicate the model misinterpreted the intent and over‑engineered the query.",
MORTAR_003,,What are the Supply Air Temperature Sensors and the equipment they belong to?,lbl/cborg-coder,Misunderstanding User Intent,"The generated query matches sensors with the exact class `brick:Supply_Air_Temperature_Sensor` using `?sensor a brick:Supply_Air_Temperature_Sensor` and does not follow the subclass hierarchy (`rdf:type/rdfs:subClassOf*`) that the ground‑truth query uses to capture all sensors that are subclasses of the target type. Consequently, it may miss valid sensors, indicating a misinterpretation of the user’s request to retrieve *all* Supply Air Temperature Sensors and their equipment.",
MORTAR_003,,List the supply air temperature sensors and the equipment that has point to them,lbl/cborg-coder,Topological Mismatch,"The generated query uses '?sensor a brick:Supply_Air_Temperature_Sensor' which only matches instances explicitly typed as that class, whereas the ground‑truth query uses '?sp rdf:type/rdfs:subClassOf* brick:Supply_Air_Temperature_Sensor' to also capture instances of any subclass. This omission reflects an incorrect assumption about the graph topology (class hierarchy) and leads to incomplete results.",
MORTAR_003,,Which pieces of equipment include a sensor for measuring supply air temperature,lbl/cborg-coder,Topological Mismatch,"The generated query adds a direct type constraint '?equipment a brick:Equipment' and only returns equipment, whereas the ground‑truth query does not restrict equipment to a specific class and also returns the sensor variable. By assuming that equipment is directly of type brick:Equipment (instead of allowing subclasses via rdf:type/rdfs:subClassOf*), the model may miss equipment that are only typed as subclasses (e.g., Air_Handling_Unit, VAV). This mismatch of graph topology leads to an incomplete answer.",
MORTAR_003,,Which devices measure supply air temperature,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the predicate `brick:measures` (e.g., `?sensor brick:measures brick:Supply_Air_Temperature`) and the class `brick:Temperature_Sensor`. Neither `brick:measures` nor a generic `brick:Temperature_Sensor` are defined in the Brick schema for representing supply‑air‑temperature sensors; the correct pattern is to query for subclasses of `brick:Supply_Air_Temperature_Sensor` and use relationships like `brick:hasPoint`/`brick:isPointOf`. This indicates the model invented or mis‑used ontology terms.",Misunderstanding User Intent
MORTAR_003,,What equipment monitors the supply air temperature,lbl/cborg-coder,Vocabulary Hallucination,The generated query uses non‑existent or incorrect Brick classes: it treats the equipment as a brick:Temperature_Sensor (whereas the equipment should be any device that has a point) and it looks for a point of type brick:Supply_Air_Temperature (the correct class in Brick is brick:Supply_Air_Temperature_Sensor). The ground‑truth query correctly uses brick:Supply_Air_Temperature_Sensor (or its subclasses) for the point and does not impose an incorrect type on the equipment.,Topological Mismatch
MORTAR_003,,Where in the system is supply air temperature measured,lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct relationship between the temperature sensor and its location using `brick:hasLocation` and selects the sensor itself, while the ground‑truth query discovers the equipment that *has* the supply‑air temperature point via `brick:hasPoint`. The model ignored the required intermediate `hasPoint` edge and the need to traverse subclass hierarchy (`rdf:type/rdfs:subClassOf*`). This mismatch of graph topology leads to an incorrect answer.",
MORTAR_004,,What equipment has sensors for zone air temperature and what are they?,lbl/cborg-coder,Misunderstanding User Intent,"The generated query adds a type constraint `?equipment a brick:Equipment .` which is absent from the ground‑truth query. This unnecessary filter changes the semantics of the request, potentially omitting equipment that has the temperature sensors but is not explicitly typed as brick:Equipment, thus not faithfully answering the user's question.",
MORTAR_004,,What are the Zone Air Temperature Sensors and the equipment they belong to?,lbl/cborg-coder,Topological Mismatch,"The generated query uses a direct type assertion `?sensor a brick:Zone_Air_Temperature_Sensor` and expects a direct `?equipment brick:hasPoint ?sensor` relationship. The ground‑truth query accounts for the class hierarchy with `rdf:type/rdfs:subClassOf* brick:Zone_Air_Temperature_Sensor`, capturing sensors that are instances of subclasses of Zone_Air_Temperature_Sensor. This mismatch of assuming a direct relationship where an indirect (subclass) relationship may exist is a topological mismatch.",
MORTAR_004,,Which zone air temperature sensor instances are connected by has point to which equipment?,lbl/cborg-coder,Topological Mismatch,The generated query uses a direct type triple '?sensor a brick:Zone_Air_Temperature_Sensor .' which assumes sensors are explicitly typed with that class. The ground truth expands through the class hierarchy with '?sensor rdf:type/rdfs:subClassOf* brick:Zone_Air_Temperature_Sensor .' to capture subclass instances. This mismatch in graph topology (ignoring subclass edges) leads to missing results.,
MORTAR_004,,Which pieces of equipment include a sensor that measures the air temperature in a zone?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses `brick:Air_Temperature_Sensor`, `brick:measures`, and `brick:isLocatedIn` which are not appropriate for the desired query. The ground‑truth uses the subclass `brick:Zone_Air_Temperature_Sensor` and does not require the extra `measures` or location predicates. These terms are either non‑existent or mis‑applied in Brick, indicating the model invented or hallucinated vocabulary.",
MORTAR_004,,What devices are fitted with zone temperature sensors and what are those sensors?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the class `brick:Zone_Temperature_Sensor`, which is not defined in the Brick schema. The correct class in the ground truth is `brick:Zone_Air_Temperature_Sensor`. This invented term causes the query to fail, indicating a vocabulary hallucination.",
MORTAR_004,,Where can I find the equipment that provides measurements of temperature in each zone?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for the equipment that provides temperature measurements for each zone. The generated query returns sensors and zones (using brick:Temperature_Sensor and brick:hasLocation) and never binds or returns any equipment entity, whereas the ground‑truth query retrieves equipment via brick:hasPoint linking equipment to the sensor. This shows the model interpreted the request as ""find sensors in zones"" rather than ""find equipment that has such sensors"".",
MORTAR_004,,Which devices monitor the temperature in the building zones?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for devices that monitor temperature in building zones, but the generated query selects sensors (?sensor) and zones, never retrieves any device/equipment entity. It uses `?sensor a brick:Temperature_Sensor` and `?sensor brick:hasLocation ?zone` rather than traversing from equipment to its points as in the ground‑truth (`?equipment brick:hasPoint ?sensor`). This shows the model interpreted the request as “give me the temperature sensors”, not “give me the devices that contain those sensors.”",Topological Mismatch
MORTAR_005,,Which zone air temperature sensors and setpoints are linked to the same equipment?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the generic classes brick:Temperature_Sensor and brick:Temperature_Setpoint, whereas the user asked for *zone air* temperature sensors and setpoints. The ground‑truth query correctly subsumes brick:Zone_Air_Temperature_Sensor and brick:Zone_Air_Temperature_Setpoint via rdfs:subClassOf*. The model’s choice of the broader terms reflects an invented (or misapplied) vocabulary that does not capture the required domain concept.",
MORTAR_005,,Find all connected pairs of Zone Air Temperature Sensors and Setpoints,lbl/cborg-coder,Topological Mismatch,"The generated query attempts to connect sensors and setpoints using direct relationships '?sensor brick:isPointOf ?zone' and '?setpoint brick:isPointOf ?zone' (or isPartOf), whereas the ground truth connects them indirectly via an equipment node with 'brick:hasPoint' (e.g., ?equip brick:hasPoint ?sensor ; ?equip brick:hasPoint ?sp). This assumption of a direct zone relationship mismatches the actual graph topology required to relate the points.",
MORTAR_005,,"Which equipment has a zone air temperature sensor and a zone air temperature setpoint, and what are the names of those sensor and setpoint points?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct brick:hasPoint relationship from the equipment to both the Zone_Air_Temperature_Sensor and Zone_Air_Temperature_Setpoint (e.g., `?equipment brick:hasPoint ?sensor .` and `?equipment brick:hasPoint ?setpoint .`). The ground‑truth query (and typical Brick topology) expects the points to be associated via a shared intermediate entity (e.g., a zone) or at least to respect the graph’s hierarchical structure, which the model does not explore. This direct‑link assumption can miss valid equipment where the sensor and setpoint are linked indirectly, indicating a topological mismatch.",
MORTAR_005,,"For each HVAC unit, what temperature sensor is installed and what setpoint does it have for controlling room air temperature?",lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses non‑existent or incorrect Brick terms: it selects `?hvac a brick:HVAC_Equipment` (the correct class is `brick:Equipment`), it looks for `brick:Temperature_Sensor` and `brick:Temperature_Setpoint` (the appropriate classes are `brick:Zone_Air_Temperature_Sensor` and `brick:Zone_Air_Temperature_Setpoint`), and it uses the property `bf:hasPoint` instead of the standard `brick:hasPoint`. These vocabularies do not match the ground‑truth query and the Brick schema.",
MORTAR_005,,What measurement and target temperature points are associated with each device that manages zone air temperature?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses terms that are not part of the Brick ontology, e.g., `brick:Device` as a class and the property `brick:controls`. The correct schema uses `brick:Equipment` (or its subclasses) and does not define a `controls` predicate for relating equipment to a zone air temperature instance. These invented vocabulary items lead to a query that does not match the actual graph topology.",Topological Mismatch
MORTAR_005,,"Which devices control the air temperature in building zones, and what sensors and desired values do they use?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct link from a controller to a zone using the predicate `brick:serves` (i.e., `?controller brick:serves ?zone . ?zone a brick:Zone`). The ground‑truth query never uses such a relationship; it connects devices to temperature sensors and setpoints via `brick:hasPoint` and relies on subclass relations of the points. This mismatch of graph topology (direct controller‑zone edge vs. indirect connection through points) leads to an incorrect query.",Vocabulary Hallucination
MORTAR_005,,How are room temperature measurements and their target values defined across the building’s equipment?,lbl/cborg-coder,Topological Mismatch,The generated query assumes a direct spatial relationship between rooms and HVAC equipment using `brick:hasLocation` and retrieves setpoints via `brick:isPointOf` and `brick:hasLocation`. The ground‑truth query instead links sensors and setpoints to equipment via `brick:hasPoint` and relies on subclass traversal (Zone_Air_Temperature_Sensor → Zone_Air_Temperature_Setpoint). This mismatch in graph topology (room → equipment → point vs. equipment → point) shows the model assumed a direct connection that does not exist in the actual data model.,Vocabulary Hallucination
MORTAR_006,,Find all sensor and setpoints connected to the same equipment,lbl/cborg-coder,Misunderstanding User Intent,"The model generated a query that forces ?equipment, ?sensor, and ?setpoint to be instances of the generic classes brick:Equipment, brick:Sensor, and brick:Setpoint, and also selects equipment labels. The ground‑truth query only requires that ?sensor and ?setpoint be (sub)classes of brick:Sensor and brick:Setpoint and that they share a brick:hasPoint relationship with the same equipment. By adding unnecessary type constraints and extra variables, the model misinterpreted the user's request, producing an over‑constrained query that does not match the intended pattern.",
MORTAR_006,,Find all related sensor and setpoints pairs,lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct relationship `?sensor brick:feeds ?setpoint`, linking a Sensor directly to a Setpoint. The ground‑truth query instead relates sensors and setpoints via a common equipment node using `brick:hasPoint` (i.e., `?equip brick:hasPoint ?sp . ?equip brick:hasPoint ?sensor`). This shows the model incorrectly presumed a direct edge that does not exist in the Brick graph.",
MORTAR_006,,Which brick sensors and brick setpoints are connected to the same equipment?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query introduces a class `brick:Equipment` (e.g., `?equipment a brick:Equipment .`) which does not exist in the Brick ontology. The ground‑truth query does not require this class; it simply looks for any entity that has both a sensor and a setpoint via `brick:hasPoint`. Inventing the non‑existent `brick:Equipment` class is a clear case of using incorrect vocabulary.",
MORTAR_006,,"For each piece of equipment that has points, what sensor and what setpoint are linked to it via the has point relationship?",lbl/cborg-coder,Topological Mismatch,"The generated query uses direct type statements such as `?sensor a brick:Sensor` and `?setpoint a brick:Setpoint` (and `?equipment a brick:Equipment`) instead of the subclass‑traversal pattern `rdf:type/rdfs:subClassOf* brick:Sensor` etc. that appears in the ground‑truth query. This assumes a direct relationship where the actual graph may contain indirect type hierarchies, causing missed matches.",
MORTAR_006,,"For every device, which measurement instrument and which control value does it include?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct type assertion for the measurement instrument and control value (`?instrument a brick:Sensor .` and `?control a brick:Setpoint .`) and also restricts the container to `brick:Device`. The ground‑truth query uses a subclass traversal (`rdf:type/rdfs:subClassOf* brick:Sensor` and `... brick:Setpoint`) and does not limit the container to a specific class, reflecting that sensors and setpoints may be connected via indirect type relationships. This mismatch shows the model assumed direct relationships/types where the graph requires indirect (subclass) relationships.",
MORTAR_006,,Which assets combine a monitoring device with an adjustable target value?,lbl/cborg-coder,Misunderstanding User Intent,"The generated query only selects the asset (?asset) and never returns the sensor or setpoint variables, whereas the ground‑truth query returns the sensor, setpoint, and equipment (?sensor, ?sp, ?equip). This indicates the model interpreted the question as asking solely for assets, omitting the additional entities the intended answer requires.",
MORTAR_006,,What equipment units offer both sensing functionality and settable thresholds?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for equipment units that have both sensing functionality and settable thresholds. The ground‑truth query returns the equipment together with the associated sensor and setpoint variables (SELECT ?sensor ?sp ?equip). The generated query only selects the equipment (and optional label) and never binds ?sensor or ?setpoint in the SELECT clause, thus omitting part of the information the user implicitly expects. This indicates a misinterpretation of the required result shape.",
MORTAR_006,,Which devices in the system support both readings and configuration settings?,lbl/cborg-coder,Topological Mismatch,"The generated query assumes that devices are directly instances of brick:Equipment and that points are directly instances of brick:Sensor and brick:Setpoint (e.g., `?device a brick:Equipment . ?reading a brick:Sensor . ?config a brick:Setpoint`). The ground‑truth query uses subclass traversal (`rdf:type/rdfs:subClassOf* brick:Sensor`, `... brick:Setpoint`) to handle cases where sensors or setpoints are subclasses of those classes. By not accounting for the class hierarchy, the generated query will miss valid devices whose points are typed with subclasses, indicating a mismatch in the expected topological (class/subclass) relationships.",
MORTAR_007,,Which AHUs have both a Cooling Valve Command and a Heating Command point?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the class `brick:Cooling_Valve_Command` which does not exist in the Brick schema. The correct class is `brick:Cooling_Command` as shown in the ground truth. This invented term shows the model hallucinated vocabulary. Additionally, the query uses `brick:Heating_Command` which is valid, but the mismatch in cooling point class demonstrates the primary failure.",
MORTAR_007,,Find all AHUs with heating and cooling command points,lbl/cborg-coder,Topological Mismatch,"The generated query assumes direct type assertions (e.g., `?ahu a brick:Air_Handling_Unit .` and `?heatCmd a brick:Heating_Command .`) whereas the ground‑truth query uses subclass closure (`rdf:type/rdfs:subClassOf*`) to capture entities that are subclasses of those Brick classes. This reflects an incorrect assumption about graph topology – the model ignores indirect type relationships.",
MORTAR_007,,Which air handler units have both a cooling and heating command?,lbl/cborg-coder,Topological Mismatch,"The generated query uses direct type assertions (?ahu a brick:Air_Handling_Unit and ?coolCmd a brick:Cooling_Command, ?heatCmd a brick:Heating_Command) assuming the AHU and points are directly instances of those classes. The ground‑truth query employs rdf:type/rdfs:subClassOf* to traverse subclass hierarchies, indicating that the correct relationship is indirect via subclasses. This mismatch shows the model assumed a direct relationship that may not exist in the graph.",
MORTAR_007,,Is there any simultaneous heating and cooling fault in any of my AHUs?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked whether any AHU has a simultaneous heating and cooling fault. The ground‑truth query simply checks for the presence of both a Heating_Command point and a Cooling_Command point attached to the same AHU. The generated query adds extra logic that retrieves the current values of those command points and filters for both being ""ON"" (e.g., FILTER (str(?heatVal) = ""1"" || ... )). This extra value‑checking was not part of the user intent and deviates from the expected answer, indicating a misunderstanding of what the question required.",
MORTAR_007,,"Which air handling unit has point a cooling command and has point a heating command, and what are those points?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct rdf:type relationship (`?ahu a brick:Air_Handling_Unit` and `?coolCmd a brick:Cooling_Command`) while the ground‑truth query uses a subclass closure (`rdf:type/rdfs:subClassOf* brick:Air_Handling_Unit` and similarly for the point classes). This mismatch means the model expects the entities to be directly instances of the classes, ignoring the possible indirect (subclass) connections present in the graph topology.",
MORTAR_007,,"Which air handling unit provides both a cooling command point and a heating command point, and what are those points?",lbl/cborg-coder,Topological Mismatch,"The generated query uses direct type assertions (`?ahu a brick:Air_Handling_Unit` and `?coolCmd a brick:Cooling_Command`, `?heatCmd a brick:Heating_Command`) and expects the AHU to have the points directly. The ground truth query uses `rdf:type/rdfs:subClassOf*` to traverse subclass hierarchies for both the AHU and the command points, reflecting that the relationships are indirect via subclassing. This mismatch between assumed direct connections and the required topological (subclass) navigation indicates a Topological Mismatch.",
MORTAR_007,,"For each air handling unit, list its cooling and heating command points.",lbl/cborg-coder,Misunderstanding User Intent,"The generated query uses OPTIONAL blocks for both cooling and heating command points, which will return AHUs even when one or both points are missing. The user asked for ""each air handling unit, list its cooling and heating command points,"" implying that both points should be present for each AHU. The ground‑truth query requires that the AHU has both a Cooling_Command and a Heating_Command (by directly binding both points), whereas the generated query does not enforce this requirement.",
MORTAR_007,,Which control points handle cooling and heating in air handling units?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for control points that handle cooling and heating in AHUs. The ground‑truth query selects points of type brick:Cooling_Command and brick:Heating_Command (or their subclasses). The generated query instead retrieves any point attached to an AHU and filters by regex on the class name (""Cooling"" or ""Heating""), which can match unrelated classes (e.g., Cooling_Temperature_Sensor) and does not enforce the specific command point semantics the user intended.",
MORTAR_007,,How can I find the temperature control setpoints for the air handling equipment?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for ""temperature control setpoints for the air handling equipment"". The ground‑truth query retrieves Cooling_Command and Heating_Command points (the actual control setpoints). The model instead generated a query that looks for points of type brick:Temperature_Setpoint, assuming the user wanted temperature setpoint data rather than the heating/cooling command points. This mismatch shows the model misinterpreted the user's intent.",
MORTAR_008,,Find all Building electrical meters and outside air temperature sensors in my building,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the class `brick:Electrical_Meter` for building electrical meters, which does not exist in the Brick ontology; the correct class is `brick:Building_Electrical_Meter`. This invented vocabulary causes the query to miss the intended instances. The ground‑truth query correctly uses `brick:Building_Electrical_Meter` (via subclass traversal).",Topological Mismatch
MORTAR_008,,Which electric meters and OAT sensors are present in the building system?,lbl/cborg-coder,Misunderstanding User Intent,"The user asked for ""electric meters and OAT sensors are present in the building system"" expecting two separate result sets (or two columns) as shown in the ground‑truth query (SELECT ?meter ?oat ...). The model generated a UNION query with a single variable ?entity, collapsing both types into one column and therefore not matching the intended output structure. It also omitted the subclass expansion pattern (rdf:type/rdfs:subClassOf*) that the ground‑truth uses, indicating a mismatch in understanding how the result should be shaped.",
MORTAR_008,,Which meters and weather sensors are present in the building system?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses class URIs `brick:Meter` and `brick:Weather_Sensor`, which are not defined in the Brick schema. The correct classes are `brick:Building_Electrical_Meter` and `brick:Outside_Air_Temperature_Sensor` (or their subclass hierarchies). Inventing these non‑existent classes causes the query to fail to match any data.",
MORTAR_008,,How can I compare the weather with electricity consumption?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses Brick terms that do not exist in the schema, e.g., `brick:Weather_Temperature_Observation`, `brick:Electric_Energy_Observation`, and properties like `brick:hasTimestamp` and `brick:hasValue`. The correct Brick ontology uses classes such as `brick:Outside_Air_Temperature_Sensor` and `brick:Building_Electrical_Meter`; observation classes and value properties are not defined this way. These fabricated vocabulary items cause the query to be invalid and diverge from the ground‑truth query.",Topological Mismatch
MORTAR_008,,Which devices serve as building power meters and which ones measure outside air temperature?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the class `brick:Power_Meter` to select power meters, but the Brick ontology defines the appropriate class as `brick:Building_Electrical_Meter` (or its subclasses). `brick:Power_Meter` does not exist in the schema, indicating the model invented an incorrect vocabulary term. The ground‑truth query correctly uses `brick:Building_Electrical_Meter` (with subclass reasoning).",
MORTAR_008,,Which electricity meters in the building and which outdoor temperature sensors are available?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query filters on brick:Electric_Meter and brick:Outdoor_Temperature_Sensor, which are not valid Brick classes. The ground‑truth uses the correct classes brick:Building_Electrical_Meter and brick:Outside_Air_Temperature_Sensor (and traverses subclasses with rdfs:subClassOf*). Inventing the terms ""Electric_Meter"" and ""Outdoor_Temperature_Sensor"" shows the model hallucinated vocabulary.",
MORTAR_008,,List all electricity usage meters alongside the devices that record outside air temperature.,lbl/cborg-coder,Topological Mismatch,"The generated query uses direct type assertions '?meter a brick:Building_Electrical_Meter' and '?sensor a brick:Outside_Air_Temperature_Sensor', ignoring that the required instances may be subclasses of these Brick classes. The ground‑truth query correctly employs 'rdf:type/rdfs:subClassOf*' to capture both direct and indirect subclass instances, indicating the model assumed a direct relationship where an indirect (subclass) relationship is needed.",
MORTAR_008,,What devices monitor electricity consumption and outdoor temperature?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the class brick:Electrical_Meter, which does not exist in the Brick ontology; the correct class is brick:Building_Electrical_Meter (or its subclasses). This invented vocabulary leads to an incorrect query that cannot match any instances. The query also omits the required subclass traversal (rdfs:subClassOf*), but the primary error is the use of a non‑existent class.",
MORTAR_009,,Which temperature sensors are connected to VAVs that serve HVAC zones?,lbl/cborg-coder,Vocabulary Hallucination,The generated query uses properties that do not exist (or are not appropriate) in the Brick ontology: it links sensors to VAVs via `brick:isPointOf` (instead of the correct `brick:hasPoint` inverse) and connects VAVs to zones via `brick:serves` (instead of the Brick property `brick:feeds` with a transitive path). These incorrect predicates indicate the model hallucinated vocabulary rather than using the valid Brick schema.,
MORTAR_009,,List all temperature sensors and the VAVs and zones they are part of.,lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct ?vav brick:isPartOf ?zone relationship and a fallback ?sensor brick:isLocationOf ?zone, which do not reflect the actual graph topology. The correct query uses the transitive brick:feeds+ predicate from VAV to HVAC_Zone and proper subclass reasoning. This mismatch of relationship direction and missing transitive path indicates a topological mismatch.",
MORTAR_009,,List the rooms and their hvac equipment that contains a temperature sensor,lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct relationship between HVAC equipment and a room using `?equip brick:hasLocation ?room`. The ground‑truth query shows that the correct topology is indirect: temperature sensors are points of a VAV, the VAV feeds one or more HVAC zones (`brick:feeds+ ?zone`), and zones are the entities associated with rooms. This mismatch in graph topology causes the generated query to look for a non‑existent direct location edge.",
MORTAR_009,,How can I learn the rooms and their temperature?,lbl/cborg-coder,ERROR,Received empty model response,
MORTAR_009,,"Which VAV units have a point temperature sensor and feed an HVAC zone, and what are the corresponding sensor and zone for each unit?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct VAV-to-zone link with `?vav brick:feeds ?zone .` and a direct type assertion `?vav a brick:VAV .`, whereas the ground‑truth query uses subclass reasoning (`rdf:type/rdfs:subClassOf* brick:VAV`) and a transitive property path (`brick:feeds+ ?zone`). This indicates the model incorrectly modeled the graph topology, assuming direct relationships that in the actual schema are indirect or hierarchical.",
MORTAR_009,,"Which variable air volume boxes are linked to temperature sensors, and which conditioned spaces do they serve?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct `brick:feeds ?space` relationship between VAVs and conditioned spaces and filters for `brick:Room` or `brick:HVAC_Zone`. The ground‑truth query uses the transitive path `brick:feeds+ ?zone` and only expects the zone to be a `brick:HVAC_Zone`. This mismatch shows the model assumed a direct edge where the graph actually requires an indirect (potentially multi‑hop) connection, which is a classic topological mismatch.",
MORTAR_009,,"For each air terminal equipped with a temperature sensor, which HVAC zones does it supply?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct `brick:feeds` relationship from the air terminal to the HVAC zone (`?airTerminal brick:feeds ?zone`). The ground‑truth query shows that the correct path is indirect, using a VAV device and a transitive `feeds+` relationship (`?vav brick:feeds+ ?zone`). This indicates a mismatch in graph topology, as the model ignored the intermediate VAV node and the need for a transitive closure. Additionally, the model used `brick:Air_Terminal` instead of the appropriate `brick:VAV`, which further reflects an incorrect understanding of the entity hierarchy.",Vocabulary Hallucination
MORTAR_009,,Which areas receive airflow from terminals that include temperature sensors?,lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct brick:feeds relationship between a generic brick:Terminal and an area (?terminal brick:feeds ?area), whereas the ground‑truth query requires an intermediate VAV device and a transitive feeds+ path (?vav brick:feeds+ ?zone) with the zone typed as brick:HVAC_Zone. This mismatch of graph topology leads to an incorrect query structure.",
MORTAR_009,,How is temperature monitored across the different HVAC zones in the building?,lbl/cborg-coder,Topological Mismatch,The generated query directly relates a temperature sensor to an HVAC zone with `?tempSensor brick:hasLocation ?zone` and selects zones with `?zone a brick:HVAC_Zone`. The ground‑truth query shows that a sensor is attached to a VAV (`brick:hasPoint`) and the VAV feeds the zone via `brick:feeds+`. The model therefore assumed a direct sensor‑to‑zone relationship that does not exist in the graph.,Vocabulary Hallucination
DFLEXLIBS_001,,"For each HVAC zone in the building, what are the timeseries IDs for the available zone temperature sensor' points, min and max temperature setpoints, temperature setpoints (single, heating/cooling or occupied/unoccupied), occupancy sensors and commands, and any related VAV damper, discharge temperature, and reheat command points?",lbl/cborg-coder,Topological Mismatch,"The generated query assumes a direct `brick:hasPart` link from an HVAC zone to a VAV box (`?zone brick:hasPart ?vav . ?vav a brick:Variable_Air_Volume_Box_With_Reheat`) while the ground‑truth model connects the VAV to the zone via `brick:feeds ?zone`. Also the query retrieves timeseries IDs directly with `ref:hasTimeseriesId` on the point, whereas the correct model uses an intermediate `ref:hasExternalReference` node (`ref:hasExternalReference/ref:hasTimeseriesId`). These incorrect graph traversals show a mismatch between the assumed topology and the actual Brick schema.",
DFLEXLIBS_002,,"For each AHU that supplies a zone, what are the timeseries IDs for all available points for supply air temperature, supply air flow, and supply air flow setpoint?",lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses predicates that are not defined in the Brick schema, such as `brick:hasTimeseries` and attempts to retrieve a timeseries ID via `rdfs:label`. The correct approach (shown in the ground‑truth query) is to use the reference namespace (`ref:hasExternalReference/ref:hasTimeseriesId`). This indicates the model invented vocabulary. Additionally, the query assumes a direct `brick:feeds` relationship between an AHU and a Zone, while the correct topology requires a two‑hop path (`brick:feeds/brick:feeds`). This shows a topological mismatch as a secondary issue.",Topological Mismatch
DFLEXLIBS_002,,"For the air handling unit that feeds a zone, what are the timeseries IDs of its supply air temperature sensor, supply air flow sensor, and supply air flow setpoint?",lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the predicate `brick:hasTimeseries` to retrieve timeseries IDs (e.g., `?temp_sensor brick:hasTimeseries ?temp_ts`). This predicate does not exist in the Brick schema; the correct pattern in the ground‑truth query is `ref:hasExternalReference/ref:hasTimeseriesId`. This invented vocabulary indicates a hallucination of ontology terms.
Additionally, the query assumes a direct `brick:feeds` relation between an AHU and a zone (`?ahu brick:feeds ?zone`), whereas the ground‑truth uses a two‑step path `brick:feeds/brick:feeds` to capture the indirect topology. This shows a secondary topological mismatch.",Topological Mismatch
DFLEXLIBS_002,,"Which timeseries identifiers correspond to the supply air temperature measurement, supply air flow measurement, and flow setpoint of the AHU supplying air to a space?",lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the class `brick:Supply_Air_Temperature_Setpoint` for the setpoint point (`?setpointPoint a brick:Supply_Air_Temperature_Setpoint .`). The ground‑truth query (and the underlying graph) expects a flow setpoint, i.e., `brick:Supply_Air_Flow_Setpoint`. This incorrect class name is an invented/incorrect vocabulary term, leading to a query that would not match any data.",
DFLEXLIBS_002,,"How can I retrieve the timeseries IDs for an AHU’s supply air temperature, airflow rate readings, and its airflow setpoint?",lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses the predicate `brick:hasTimeseriesId` for both sensors and the setpoint (e.g., `?temp_sensor brick:hasTimeseriesId ?temp_ts`). This property does not exist in the Brick ontology; the correct way to retrieve a timeseries ID is via the reference namespace `ref:hasExternalReference/ref:hasTimeseriesId` as shown in the ground‑truth query. Additionally, the query invents a direct `brick:hasPoint` relationship from the AHU to its points, bypassing the required `brick:feeds/brick:feeds` intermediate zone relationship, indicating a topological mismatch as a secondary issue.",Topological Mismatch
DFLEXLIBS_002,,Where can I find the timeseries IDs for an air handling unit’s supply-side measurements?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query uses predicates that do not exist in the Brick schema, e.g., `brick:hasTimeseries` to retrieve a timeseries identifier and `brick:hasPart` to relate an AHU to its sensors. The correct model uses `brick:hasPoint` (or the `brick:feeds/brick:feeds` pattern) and accesses timeseries via `brick:hasExternalReference` → `ref:hasTimeseriesId`. These invented terms indicate a hallucination of vocabulary.",Topological Mismatch
DFLEXLIBS_002,,How do I access the supply air measurement data for an AHU?,lbl/cborg-coder,Vocabulary Hallucination,"The generated query references the class brick:Supply_Air_Static_Pressure_Sensor in the FILTER clause, but the building summary shows no instances of that class (class_counts list includes only Supply_Air_Temperature_Sensor and Supply_Air_Flow_Sensor). This term does not exist in the current Brick schema deployment, indicating the model invented a vocabulary term. Additionally, the query includes brick:Mixed_Air_Temperature_Sensor as a ""supply"" type, which is semantically unrelated.",
